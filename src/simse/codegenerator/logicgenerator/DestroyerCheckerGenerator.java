/*
 * This class is responsible for generating all of the code for the destroyer
 * checker component in the Logic component of SimSE
 */

package simse.codegenerator.logicgenerator;

import simse.codegenerator.CodeGeneratorConstants;
import simse.codegenerator.CodeGeneratorUtils;

import simse.modelbuilder.objectbuilder.AttributeTypes;
import simse.modelbuilder.objectbuilder.SimSEObjectTypeTypes;
import simse.modelbuilder.actionbuilder.ActionType;
import simse.modelbuilder.actionbuilder.ActionTypeDestroyer;
import simse.modelbuilder.actionbuilder.ActionTypeParticipant;
import simse.modelbuilder.actionbuilder.ActionTypeParticipantAttributeConstraint;
import simse.modelbuilder.actionbuilder.ActionTypeParticipantConstraint;
import simse.modelbuilder.actionbuilder.ActionTypeParticipantDestroyer;
import simse.modelbuilder.actionbuilder.AttributeGuard;
import simse.modelbuilder.actionbuilder.AutonomousActionTypeDestroyer;
import simse.modelbuilder.actionbuilder.DefinedActionTypes;
import simse.modelbuilder.actionbuilder.RandomActionTypeDestroyer;
import simse.modelbuilder.actionbuilder.TimedActionTypeDestroyer;
import simse.modelbuilder.actionbuilder.UserActionTypeDestroyer;
import simse.modelbuilder.rulebuilder.Rule;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import java.util.Vector;

import javax.swing.JOptionPane;

public class DestroyerCheckerGenerator implements CodeGeneratorConstants {
  private File directory; // directory to save generated code into
  private DefinedActionTypes actTypes; 
  private FileWriter writer;
  private File destFile;
  private Vector<ActionTypeDestroyer> nonPrioritizedDestroyers;
  private Vector<ActionTypeDestroyer> prioritizedDestroyers;
  private Vector<ActionTypeDestroyer> allDestroyers;

  public DestroyerCheckerGenerator(DefinedActionTypes actTypes, 
  		File directory) {
    this.actTypes = actTypes;
    this.directory = directory;
    initializeDestroyerLists();
  }

  public void generate() {
    try {
      destFile = new File(directory, ("simse\\logic\\DestroyerChecker.java"));
      if (destFile.exists()) {
        destFile.delete(); // delete old version of file
      }
      writer = new FileWriter(destFile);
      writer
          .write("/* File generated by: simse.codegenerator.logicgenerator.DestroyerCheckerGenerator */");
      writer.write(NEWLINE);
      writer.write("package simse.logic;");
      writer.write(NEWLINE);
      writer.write("import simse.state.*;");
      writer.write(NEWLINE);
      writer.write("import simse.gui.*;");
      writer.write(NEWLINE);
      writer.write("import simse.adts.objects.*;");
      writer.write(NEWLINE);
      writer.write("import simse.adts.actions.*;");
      writer.write(NEWLINE);
      writer.write("import java.util.*;");
      writer.write(NEWLINE);
      writer.write("import javax.swing.*;");
      writer.write(NEWLINE);
      writer.write("public class DestroyerChecker");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);

      // member variables:
      writer.write("private State state;");
      writer.write(NEWLINE);
      writer.write("private RuleExecutor ruleExec;");
      writer.write(NEWLINE);
      writer.write("private TriggerChecker trigCheck;");
      writer.write(NEWLINE);
      writer.write("private Random ranNumGen;");
      writer.write(NEWLINE);

      // constructor:
      writer
          .write("public DestroyerChecker(State s, RuleExecutor r, TriggerChecker t)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("state = s;");
      writer.write(NEWLINE);
      writer.write("ruleExec = r;");
      writer.write(NEWLINE);
      writer.write("trigCheck = t;");
      writer.write(NEWLINE);
      writer.write("ranNumGen = new Random();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);

      // update function:
      writer
          .write("public void update(boolean updateUserDestsOnly, JFrame gui)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("Vector<simse.adts.actions.Action> actions = state.getActionStateRepository().getAllActions();");
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<actions.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer
          .write("simse.adts.actions.Action tempAct = actions.elementAt(i);");
      writer.write(NEWLINE);
      // go through each destroyer:
      for (int i = 0; i < allDestroyers.size(); i++) {
        ActionTypeDestroyer tempDest = allDestroyers.elementAt(i);
        ActionType tempAct = tempDest.getActionType();
        /*
         * if(i > 0) // not on first element { writer.write("else "); }
         */
        writer.write("if((tempAct instanceof "
            + CodeGeneratorUtils.getUpperCaseLeading(tempAct.getName())
            + "Action) && (state.getActionStateRepository().get"
            + CodeGeneratorUtils.getUpperCaseLeading(tempAct.getName())
            + "ActionStateRepository().getAllActions().contains(tempAct)))");
        writer.write(NEWLINE);
        writer.write(OPEN_BRACK);
        writer.write(NEWLINE);
        writer.write(CodeGeneratorUtils.getUpperCaseLeading(
        		tempAct.getName()) + "Action " + tempAct.getName().toLowerCase() +
        		"TempAct = (" + CodeGeneratorUtils.getUpperCaseLeading(
        				tempAct.getName()) + "Action)tempAct;");
        writer.write(NEWLINE);

        if (tempDest instanceof TimedActionTypeDestroyer) { // timed destroyer
          writer.write("if(!updateUserDestsOnly)");
          writer.write(NEWLINE);
          writer.write(OPEN_BRACK);
          writer.write(NEWLINE);
          writer.write("if(" + tempAct.getName().toLowerCase() + "TempAct" +
          		".getTimeToLive() == 0)");
          writer.write(NEWLINE);
          writer.write(OPEN_BRACK);
          writer.write(NEWLINE);
          writer.write("Vector<SSObject> b = tempAct.getAllParticipants();");
          writer.write(NEWLINE);
          writer.write("for(int j=0; j<b.size(); j++)");
          writer.write(NEWLINE);
          writer.write(OPEN_BRACK);
          writer.write(NEWLINE);
          writer.write("SSObject c = b.elementAt(j);");
          writer.write(NEWLINE);
          writer.write("if(c instanceof Employee)");
          writer.write(NEWLINE);
          writer.write(OPEN_BRACK);
          writer.write(NEWLINE);
          if ((tempDest.getDestroyerText() != null)
              && (tempDest.getDestroyerText().length() > 0)) {
            writer.write("((Employee)c).setOverheadText(\""
                + tempDest.getDestroyerText() + "\");");
            writer.write(NEWLINE);
          }
          writer.write(CLOSED_BRACK);
          writer.write(NEWLINE);
          writer.write("else if(c instanceof Customer)");
          writer.write(NEWLINE);
          writer.write(OPEN_BRACK);
          writer.write(NEWLINE);
          if ((tempDest.getDestroyerText() != null)
              && (tempDest.getDestroyerText().length() > 0)) {
            writer.write("((Customer)c).setOverheadText(\""
                + tempDest.getDestroyerText() + "\");");
          }
          writer.write(NEWLINE);
          writer.write(CLOSED_BRACK);
          writer.write(NEWLINE);
          writer.write(CLOSED_BRACK);
          writer.write(NEWLINE);

          // execute all destroyer rules:
          Vector<Rule> destRules = tempAct.getAllDestroyerRules();
          for (int k = 0; k < destRules.size(); k++) {
            Rule dRule = destRules.elementAt(k);
            writer.write("ruleExec.update(gui, RuleExecutor.UPDATE_ONE, \""
                + dRule.getName() + "\", tempAct);");
            writer.write(NEWLINE);
          }
          writer.write("state.getActionStateRepository().get"
              + CodeGeneratorUtils.getUpperCaseLeading(tempAct.getName())
              + "ActionStateRepository().remove(" + 
              tempAct.getName().toLowerCase() + "TempAct);");
          writer.write(NEWLINE);
          writer.write("trigCheck.update(true, gui);");
          writer.write(NEWLINE);
          writer.write("update(false, gui);");
          writer.write(NEWLINE);

          // game-ending:
          if (tempDest.isGameEndingDestroyer()) {
            writer.write("// stop game and give score:");
            writer.write(NEWLINE);
            writer.write(
            		CodeGeneratorUtils.getUpperCaseLeading(tempAct.getName()) + 
            		"Action t111 = (" + 
            		CodeGeneratorUtils.getUpperCaseLeading(tempAct.getName()) + 
            		"Action)tempAct;");
            writer.write(NEWLINE);
            // find the scoring attribute:
            ActionTypeParticipantDestroyer scoringPartDest = null;
            ActionTypeParticipantConstraint scoringPartConst = null;
            ActionTypeParticipantAttributeConstraint scoringAttConst = null;
            Vector<ActionTypeParticipantDestroyer> partDests = 
            	tempDest.getAllParticipantDestroyers();
            for (int j = 0; j < partDests.size(); j++) {
              ActionTypeParticipantDestroyer partDest = partDests.elementAt(j);
              Vector<ActionTypeParticipantConstraint> partConsts = 
              	partDest.getAllConstraints();
              for (int k = 0; k < partConsts.size(); k++) {
                ActionTypeParticipantConstraint partConst = 
                	partConsts.elementAt(k);
                ActionTypeParticipantAttributeConstraint[] attConsts = partConst
                    .getAllAttributeConstraints();
                for (int m = 0; m < attConsts.length; m++) {
                  if (attConsts[m].isScoringAttribute()) {
                    scoringAttConst = attConsts[m];
                    scoringPartConst = partConst;
                    scoringPartDest = partDest;
                    break;
                  }
                }
              }
            }
            if ((scoringAttConst != null) && (scoringPartConst != null)
                && (scoringPartDest != null)) {
              writer.write("if(t111.getAll"
                  + scoringPartDest.getParticipant().getName()
                  + "s().size() > 0)");
              writer.write(NEWLINE);
              writer.write(OPEN_BRACK);
              writer.write(NEWLINE);
              writer.write(CodeGeneratorUtils.getUpperCaseLeading(
              		scoringPartConst.getSimSEObjectType().getName()) + " t = (" + 
              		CodeGeneratorUtils.getUpperCaseLeading(
              				scoringPartConst.getSimSEObjectType().getName()) + 
              				")(t111.getAll" + 
              				scoringPartDest.getParticipant().getName() + 
              				"s().elementAt(0));");
              writer.write(NEWLINE);
              if (scoringAttConst.getAttribute().getType() == 
              	AttributeTypes.INTEGER) {
                writer.write("int");
              } else if (scoringAttConst.getAttribute().getType() == 
              	AttributeTypes.DOUBLE) {
                writer.write("double");
              } else if (scoringAttConst.getAttribute().getType() == 
              	AttributeTypes.STRING) {
                writer.write("String");
              } else if (scoringAttConst.getAttribute().getType() == 
              	AttributeTypes.BOOLEAN) {
                writer.write("boolean");
              }
              writer.write(" v = t.get"
                  + scoringAttConst.getAttribute().getName() + "();");
              writer.write(NEWLINE);
              writer.write("state.getClock().stop();");
              writer.write(NEWLINE);
              writer.write("state.setScore(v);");
              writer.write(NEWLINE);
              writer.write("((SimSEGUI)gui).update();");
              writer.write(NEWLINE);
              writer
                  .write("JOptionPane.showMessageDialog(null, (\"Your score is \" + v), \"Game over!\", JOptionPane.INFORMATION_MESSAGE);");
              writer.write(NEWLINE);
              writer.write(CLOSED_BRACK);
              writer.write(NEWLINE);
            }
          }

          writer.write(CLOSED_BRACK);
          writer.write(NEWLINE);
//          writer.write("else");
//          writer.write(NEWLINE);
//          writer.write(OPEN_BRACK);
//          writer.write(NEWLINE);
//          writer.write("((" + getUpperCaseLeading(tempAct.getName())
//              + "Action)tempAct).decrementTimeToLive();");
//          writer.write(NEWLINE);
//          writer.write(CLOSED_BRACK);
//          writer.write(NEWLINE);
          writer.write(CLOSED_BRACK);
          writer.write(NEWLINE);
          writer.write(CLOSED_BRACK);
          writer.write(NEWLINE);
        } else { // random, user, or autonomous destroyer
          if ((tempDest instanceof RandomActionTypeDestroyer)
              || (tempDest instanceof AutonomousActionTypeDestroyer)) { 
            writer.write("if(!updateUserDestsOnly)");
            writer.write(NEWLINE);
            writer.write(OPEN_BRACK);
            writer.write(NEWLINE);
          }
          writer.write("boolean destroy = true;");
          writer.write(NEWLINE);

          Vector<ActionTypeParticipantDestroyer> destroyers = 
          	tempDest.getAllParticipantDestroyers();
          // go through each participant destroyer:
          for (int j = 0; j < destroyers.size(); j++) {
            ActionTypeParticipantDestroyer dest = destroyers.elementAt(j);
            ActionTypeParticipant part = dest.getParticipant();

            writer.write("Vector<" + SimSEObjectTypeTypes.getText(part
                .getSimSEObjectTypeType()) + "> " + 
                part.getName().toLowerCase() + "s = " + 
                tempAct.getName().toLowerCase() + "TempAct.getAll" + 
                part.getName() + "s();");
            writer.write(NEWLINE);
            writer.write("for(int j=0; j<" + part.getName().toLowerCase()
                + "s.size(); j++)");
            writer.write(NEWLINE);
            writer.write(OPEN_BRACK);
            writer.write(NEWLINE);
            writer.write(SimSEObjectTypeTypes.getText(part
                .getSimSEObjectTypeType())
                + " a = " + part.getName().toLowerCase() + "s.elementAt(j);");
            writer.write(NEWLINE);
            // go through all participant constraints:
            Vector<ActionTypeParticipantConstraint> constraints = 
            	dest.getAllConstraints();
            for (int k = 0; k < constraints.size(); k++) {
              ActionTypeParticipantConstraint constraint = 
              	constraints.elementAt(k);
              String objTypeName = constraint.getSimSEObjectType().getName();
              if (k > 0) { // not on first element
                writer.write("else ");
              }
              writer.write("if(a instanceof "
                  + CodeGeneratorUtils.getUpperCaseLeading(objTypeName) + ")");
              writer.write(NEWLINE);
              writer.write(OPEN_BRACK);
              writer.write(NEWLINE);
              // go through all attribute constraints:
              ActionTypeParticipantAttributeConstraint[] attConstraints = 
              	constraint.getAllAttributeConstraints();
              int numAttConsts = 0;
              for (int m = 0; m < attConstraints.length; m++) {
                ActionTypeParticipantAttributeConstraint tempAttConst = 
                	attConstraints[m];
                if (tempAttConst.isConstrained()) {
                  if (numAttConsts == 0) { // this is the first attribute that
                                         	 // we've come across that's 
                  												 // constrained
                    writer.write("if(");
                  } else {
                    writer.write(" || ");
                  }
                  writer.write("(!(((" + 
                  		CodeGeneratorUtils.getUpperCaseLeading(objTypeName) + 
                  		")a).get" + tempAttConst.getAttribute().getName() + "()");
                  if (tempAttConst.getAttribute().getType() == 
                  	AttributeTypes.STRING) {
                    writer.write(".equals(" + "\""
                        + tempAttConst.getValue().toString() + "\")");
                  } else {
                    if (tempAttConst.getGuard().equals(AttributeGuard.EQUALS)) {
                      writer.write(" == ");
                    } else {
                      writer.write(" " + tempAttConst.getGuard() + " ");
                    }
                    writer.write(tempAttConst.getValue().toString());
                  }
                  writer.write("))");
                  numAttConsts++;
                }
              }
              if (numAttConsts > 0) { // there is at least one constraint
                writer.write(")");
                writer.write(NEWLINE);
                writer.write(OPEN_BRACK);
                writer.write(NEWLINE);
                writer.write("destroy = false;");
                writer.write(NEWLINE);
                writer.write("break;");
                writer.write(NEWLINE);
                writer.write(CLOSED_BRACK);
                writer.write(NEWLINE);
              }
              writer.write(CLOSED_BRACK);
              writer.write(NEWLINE);
            }
            writer.write(CLOSED_BRACK);
            writer.write(NEWLINE);
          }
          writer.write("if(");
          if (tempDest instanceof RandomActionTypeDestroyer) {
            writer.write("(destroy) && ((ranNumGen.nextDouble() * 100.0) < "
                + ((RandomActionTypeDestroyer) (tempDest)).getFrequency()
                + "))");
          } else { // user, action or autonomous
            writer.write("destroy)");
          }
          writer.write(NEWLINE);
          writer.write(OPEN_BRACK);
          writer.write(NEWLINE);
          writer.write("Vector<SSObject> b = tempAct.getAllParticipants();");
          writer.write(NEWLINE);
          writer.write("for(int j=0; j<b.size(); j++)");
          writer.write(NEWLINE);
          writer.write(OPEN_BRACK);
          writer.write(NEWLINE);
          writer.write("SSObject c = b.elementAt(j);");
          writer.write(NEWLINE);
          writer.write("if(c instanceof Employee)");
          writer.write(NEWLINE);
          writer.write(OPEN_BRACK);
          writer.write(NEWLINE);
          if ((tempDest instanceof AutonomousActionTypeDestroyer)
              || (tempDest instanceof RandomActionTypeDestroyer)) {
            if ((tempDest.getDestroyerText() != null)
                && (tempDest.getDestroyerText().length() > 0)) {
              writer.write("((Employee)c).setOverheadText(\""
                  + tempDest.getDestroyerText() + "\");");
            }
            writer.write(NEWLINE);
            
            // For each user destroyer for this action, remove the menu item:
            for (int k = 0; k < allDestroyers.size(); k++) {
              ActionTypeDestroyer tempDest2 = allDestroyers.elementAt(k);
              if ((tempDest2 instanceof UserActionTypeDestroyer) &&
                  (tempDest2 != tempDest) && 
                  (tempDest2.getActionType().getName().equals(
                      tempDest.getActionType().getName()))) {
                writer.write("((Employee) c).removeMenuItem(\"" +
                    ((UserActionTypeDestroyer)tempDest2).getMenuText()
                    + "\");");
                writer.write(NEWLINE);
              }
            }
               
            writer.write(CLOSED_BRACK);
            writer.write(NEWLINE);
            writer.write("else if(c instanceof Customer)");
            writer.write(NEWLINE);
            writer.write(OPEN_BRACK);
            writer.write(NEWLINE);
            if ((tempDest.getDestroyerText() != null)
                && (tempDest.getDestroyerText().length() > 0)) {
              writer.write("((Customer)c).setOverheadText(\""
                  + tempDest.getDestroyerText() + "\");");
            }
            writer.write(NEWLINE);
            writer.write(CLOSED_BRACK);
            writer.write(NEWLINE);
            writer.write(CLOSED_BRACK);
            writer.write(NEWLINE);

            // execute all destroyer rules:
            Vector<Rule> destRules = tempAct.getAllDestroyerRules();
            for (int k = 0; k < destRules.size(); k++) {
              Rule dRule = destRules.elementAt(k);
              writer.write("ruleExec.update(gui, RuleExecutor.UPDATE_ONE, \""
                  + dRule.getName() + "\", tempAct);");
              writer.write(NEWLINE);
            }
            writer.write("state.getActionStateRepository().get"
                + CodeGeneratorUtils.getUpperCaseLeading(tempAct.getName())
                + "ActionStateRepository().remove(" + 
                tempAct.getName().toLowerCase() + "TempAct);");
            writer.write(NEWLINE);
            writer.write("trigCheck.update(true, gui);");
            writer.write(NEWLINE);
            writer.write("update(false, gui);");
            writer.write(NEWLINE);

            // game-ending:
            if (tempDest.isGameEndingDestroyer()) {
              writer.write("// stop game and give score:");
              writer.write(NEWLINE);
              writer.write(CodeGeneratorUtils.getUpperCaseLeading(
              		tempAct.getName()) + "Action t111 = (" + 
              		CodeGeneratorUtils.getUpperCaseLeading(tempAct.getName()) + 
              		"Action)tempAct;");
              writer.write(NEWLINE);
              // find the scoring attribute:
              ActionTypeParticipantDestroyer scoringPartDest = null;
              ActionTypeParticipantConstraint scoringPartConst = null;
              ActionTypeParticipantAttributeConstraint scoringAttConst = null;
              Vector<ActionTypeParticipantDestroyer> partDests = 
              	tempDest.getAllParticipantDestroyers();
              for (int j = 0; j < partDests.size(); j++) {
                ActionTypeParticipantDestroyer partDest = 
                	partDests.elementAt(j);
                Vector<ActionTypeParticipantConstraint> partConsts = 
                	partDest.getAllConstraints();
                for (int k = 0; k < partConsts.size(); k++) {
                  ActionTypeParticipantConstraint partConst = 
                  	partConsts.elementAt(k);
                  ActionTypeParticipantAttributeConstraint[] attConsts = 
                  	partConst.getAllAttributeConstraints();
                  for (int m = 0; m < attConsts.length; m++) {
                    if (attConsts[m].isScoringAttribute()) {
                      scoringAttConst = attConsts[m];
                      scoringPartConst = partConst;
                      scoringPartDest = partDest;
                      break;
                    }
                  }
                }
              }
              if ((scoringAttConst != null) && (scoringPartConst != null)
                  && (scoringPartDest != null)) {
                writer.write("if(t111.getAll"
                    + scoringPartDest.getParticipant().getName()
                    + "s().size() > 0)");
                writer.write(NEWLINE);
                writer.write(OPEN_BRACK);
                writer.write(NEWLINE);
                writer.write(CodeGeneratorUtils.getUpperCaseLeading(
                		scoringPartConst.getSimSEObjectType().getName()) + 
                		" t = (" + 
                		CodeGeneratorUtils.getUpperCaseLeading(
                				scoringPartConst.getSimSEObjectType().getName()) + 
                				")(t111.getAll" + 
                				scoringPartDest.getParticipant().getName() + 
                				"s().elementAt(0));");
                writer.write(NEWLINE);
                writer.write("if(t != null)");
                writer.write(NEWLINE);
                writer.write(OPEN_BRACK);
                writer.write(NEWLINE);
                if (scoringAttConst.getAttribute().getType() == 
                	AttributeTypes.INTEGER) {
                  writer.write("int");
                } else if (scoringAttConst.getAttribute().getType() == 
                	AttributeTypes.DOUBLE) {
                  writer.write("double");
                } else if (scoringAttConst.getAttribute().getType() == 
                	AttributeTypes.STRING) {
                  writer.write("String");
                } else if (scoringAttConst.getAttribute().getType() == 
                	AttributeTypes.BOOLEAN) {
                  writer.write("boolean");
                }
                writer.write(" v = t.get"
                    + scoringAttConst.getAttribute().getName() + "();");
                writer.write(NEWLINE);
                writer.write("state.getClock().stop();");
                writer.write(NEWLINE);
                writer.write("state.setScore(v);");
                writer.write(NEWLINE);
                writer.write("((SimSEGUI)gui).update();");
                writer.write(NEWLINE);
                writer
                    .write("JOptionPane.showMessageDialog(null, (\"Your score is \" + v), \"Game over!\", JOptionPane.INFORMATION_MESSAGE);");
                writer.write(NEWLINE);
                writer.write(CLOSED_BRACK);
                writer.write(NEWLINE);
                writer.write(CLOSED_BRACK);
                writer.write(NEWLINE);
              }
            }

            writer.write(CLOSED_BRACK);
            writer.write(NEWLINE);
            writer.write(CLOSED_BRACK);
            writer.write(NEWLINE);
          } else { // user destroyer
            writer.write("((Employee)c).addMenuItem(\"" + 
            		((UserActionTypeDestroyer) (tempDest)).getMenuText() + "\");");
            writer.write(NEWLINE);
            writer.write(CLOSED_BRACK);
            writer.write(NEWLINE);
            writer.write(CLOSED_BRACK);
            writer.write(NEWLINE);
            writer.write(CLOSED_BRACK);
            writer.write(NEWLINE);
          }
          writer.write(CLOSED_BRACK);
          writer.write(NEWLINE);
        }
      }
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("// update trigger checker:");
      writer.write(NEWLINE);
      writer.write("trigCheck.update(true, gui);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.close();
    } catch (IOException e) {
      JOptionPane.showMessageDialog(null, ("Error writing file "
          + destFile.getPath() + ": " + e.toString()), "File IO Error",
          JOptionPane.WARNING_MESSAGE);
    }
  }

  /*
   * gets the destroyers in prioritized order according to their priority
   */
  private void initializeDestroyerLists() {
    // initialize lists:
    nonPrioritizedDestroyers = new Vector<ActionTypeDestroyer>();
    prioritizedDestroyers = new Vector<ActionTypeDestroyer>();
    Vector<ActionType> allActions = actTypes.getAllActionTypes();
    // go through all action types and get their destroyers:
    for (int i = 0; i < allActions.size(); i++) {
      ActionType tempAct = allActions.elementAt(i);
      Vector<ActionTypeDestroyer> dests = tempAct.getAllDestroyers();
      for (int j = 0; j < dests.size(); j++) {
        ActionTypeDestroyer tempDest = dests.elementAt(j);
        int priority = tempDest.getPriority();
        if (priority == -1) { // destroyer is not prioritized
          nonPrioritizedDestroyers.addElement(tempDest);
        } else { // priority >= 0
          if (prioritizedDestroyers.size() == 0) { // no elements have been 
          																				 // added yet to the 
          																				 // prioritized destroyer list
            prioritizedDestroyers.add(tempDest);
          } else {
            // find the correct position to insert the destroyer at:
            for (int k = 0; k < prioritizedDestroyers.size(); k++) {
              ActionTypeDestroyer tempA = prioritizedDestroyers.elementAt(k);
              if (priority <= tempA.getPriority()) {
                prioritizedDestroyers.insertElementAt(tempDest, k); // insert
                                                                    // the
                                                                    // destroyer
                break;
              } else if (k == (prioritizedDestroyers.size() - 1)) { // on the 
              																											// last 
              																											// element
                prioritizedDestroyers.add(tempDest); // add the destroyer to the
                                                     // end of the list
                break;
              }
            }
          }
        }
      }
    }
    // make it all into one:
    allDestroyers = new Vector<ActionTypeDestroyer>();
    for (int i = 0; i < prioritizedDestroyers.size(); i++) {
      allDestroyers.add(prioritizedDestroyers.elementAt(i));
    }
    for (int i = 0; i < nonPrioritizedDestroyers.size(); i++) {
      allDestroyers.add(nonPrioritizedDestroyers.elementAt(i));
    }
  }
}