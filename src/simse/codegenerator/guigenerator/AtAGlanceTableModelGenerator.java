/*
 * This class is responsible for generating all of the code for the different
 * table models in the At-A-Glance Frames in the GUI
 */

package simse.codegenerator.guigenerator;

import simse.modelbuilder.objectbuilder.Attribute;
import simse.modelbuilder.objectbuilder.AttributeTypes;
import simse.modelbuilder.objectbuilder.DefinedObjectTypes;
import simse.modelbuilder.objectbuilder.NumericalAttribute;
import simse.modelbuilder.objectbuilder.SimSEObjectType;
import simse.modelbuilder.objectbuilder.SimSEObjectTypeTypes;
import simse.codegenerator.CodeGeneratorConstants;
import simse.codegenerator.CodeGeneratorUtils;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Vector;

import javax.swing.JOptionPane;

public class AtAGlanceTableModelGenerator implements CodeGeneratorConstants {
  private File directory; // directory to save generated code into
  private DefinedObjectTypes objTypes; // holds all of the defined object types
                                       // from an sso file

  public AtAGlanceTableModelGenerator(DefinedObjectTypes objTypes, 
  		File directory) {
    this.objTypes = objTypes;
    this.directory = directory;
  }

  public void generate() {
    Vector<SimSEObjectType> types = objTypes.getAllObjectTypes();
    for (int i = 0; i < types.size(); i++) {
      generateTableModelFile(types.elementAt(i));
    }
  }

  private void generateTableModelFile(SimSEObjectType type) {
    // generate file:
    File tableModelFile = new File(directory, ("simse\\gui\\"
        + CodeGeneratorUtils.getUpperCaseLeading(type.getName()) + 
        "TableModel.java"));
    if (tableModelFile.exists()) {
      tableModelFile.delete(); // delete old version of file
    }
    try {
      FileWriter writer = new FileWriter(tableModelFile);
      writer
          .write("/* File generated by: simse.codegenerator.guigenerator.AtAGlanceTableModelGenerator */");
      writer.write(NEWLINE);
      writer.write("package simse.gui;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("import javax.swing.table.*;");
      writer.write(NEWLINE);
      writer.write("import java.util.*;");
      writer.write(NEWLINE);
      writer.write("import java.lang.*;");
      writer.write(NEWLINE);
      writer.write("import java.text.*;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("import simse.adts.objects.*;");
      writer.write(NEWLINE);
      writer.write("import simse.state.*;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // constructor:
      writer.write("public class " + 
      		CodeGeneratorUtils.getUpperCaseLeading(type.getName())
          + "TableModel extends AbstractTableModel");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("private Vector<String> columnNames; // column names");
      writer.write(NEWLINE);
      writer.write("private Vector<Vector<Object>> data; // data in table");
      writer.write(NEWLINE);
      writer.write("private State state;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("private NumberFormat numFormat;");
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write("public " + 
      		CodeGeneratorUtils.getUpperCaseLeading(type.getName()) + 
      		"TableModel(State s)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("state = s;");
      writer.write(NEWLINE);
      writer.write("columnNames = new Vector<String>();");
      writer.write(NEWLINE);
      writer.write("data = new Vector<Vector<Object>>();");
      writer.write(NEWLINE);
      writer.write("numFormat = NumberFormat.getNumberInstance(Locale.US);");
      writer.write(NEWLINE);
      writer.write("initColNames();");
      writer.write(NEWLINE);
      writer.write("update();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // getColumnCount function:
      writer.write("public int getColumnCount()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("return columnNames.size();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // getRowCount function:
      writer.write("public int getRowCount()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("if (data.size() > 0) {");
      writer.write(NEWLINE);
      writer.write("return data.elementAt(0).size();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write("return 0;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // getColumnName function:
      writer.write("public String getColumnName(int col)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("return columnNames.elementAt(col);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // getColumnIndex function:
      writer.write("public int getColumnIndex(String columnName)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("for(int i=0; i<columnNames.size(); i++)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("String colName = columnNames.elementAt(i);");
      writer.write(NEWLINE);
      writer.write("if(colName.equals(columnName))");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("return i;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write("return -1;");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // getValueAt function:
      writer.write("public Object getValueAt(int row, int col)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("return data.elementAt(col).elementAt(row);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // setValueAt function:
      writer.write("public void setValueAt(Object value, int row, int col)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("data.elementAt(col).add(value);");
      writer.write(NEWLINE);
      writer.write("fireTableCellUpdated(row, col);");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // initColNames function:
      writer.write("private void initColNames()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      // go through all attributes:
      Vector<Attribute> atts = type.getAllAttributes();
      for (int i = 0; i < atts.size(); i++) {
        Attribute a = atts.elementAt(i);
        if (a.isVisible()) {
          writer.write("columnNames.add(\"" + a.getName() + "\");");
          writer.write(NEWLINE);
        }
      }
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // update function:
      writer.write("public void update()");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      int index = 0;

      // generate code for all visible attributes
      writer.write(NEWLINE);
      writer.write("if (!state.getClock().isStopped()) {");
      writer.write(NEWLINE);
      writer.write("Vector<" + 
      		CodeGeneratorUtils.getUpperCaseLeading(type.getName()) + "> " + 
      		type.getName().toLowerCase() + "s = state.get" + 
      		SimSEObjectTypeTypes.getText(type.getType()) + 
      		"StateRepository().get" + 
      		CodeGeneratorUtils.getUpperCaseLeading(type.getName()) + 
      		"StateRepository().getAll();");
      writer.write(NEWLINE);
      writer.write("Vector<Object> ");
      writer.write("temp = new Vector<Object>();");
      writer.write(NEWLINE);
      for (int i = 0; i < atts.size(); i++) {
        Attribute a = atts.elementAt(i);
        if (a.isVisible()) {
          writer.write("// Initialize " + a.getName() + ":");
          writer.write(NEWLINE);
          writer.write("temp = new Vector<Object>();");
          writer.write(NEWLINE);
          writer.write("for(int i=0; i<" + type.getName().toLowerCase()
              + "s.size(); i++)");
          writer.write(NEWLINE);
          writer.write(OPEN_BRACK);
          writer.write(NEWLINE);
          if (a.getType() == AttributeTypes.STRING) {
            writer.write("temp.add(" + type.getName().toLowerCase() + 
            		"s.elementAt(i).get" + 
            		CodeGeneratorUtils.getUpperCaseLeading(a.getName()) + "());");
          } else if (a.getType() == AttributeTypes.BOOLEAN) {
            writer.write("temp.add(new Boolean(" + 
            		type.getName().toLowerCase() + "s.elementAt(i).get" + 
            		CodeGeneratorUtils.getUpperCaseLeading(a.getName()) + "()));");
          } else if (a.getType() == AttributeTypes.INTEGER) {
            writer.write("numFormat.setMinimumFractionDigits(0);");
            writer.write(NEWLINE);
            writer.write("numFormat.setMaximumFractionDigits(0);");
            writer.write(NEWLINE);
            writer.write("temp.add(numFormat.format(" + 
            		type.getName().toLowerCase() + "s.elementAt(i).get" + 
            		CodeGeneratorUtils.getUpperCaseLeading(a.getName()) + "()));");
          } else if (a.getType() == AttributeTypes.DOUBLE) {
            NumericalAttribute numAtt = (NumericalAttribute) a;
            writer.write("numFormat.setMinimumFractionDigits(");
            if (numAtt.getMinNumFractionDigits() != null) // has min num
                                                          // fraction digits
            {
              writer.write(numAtt.getMinNumFractionDigits().toString());
            } else {
              writer.write("0");
            }
            writer.write(");");
            writer.write(NEWLINE);
            writer.write("numFormat.setMaximumFractionDigits(");
            if (numAtt.getMaxNumFractionDigits() != null) // has max num
                                                          // fraction digits
            {
              writer.write(numAtt.getMaxNumFractionDigits().toString());
            } else {
              writer.write("16");
            }
            writer.write(");");
            writer.write(NEWLINE);
            writer.write("temp.add(numFormat.format(" + 
            		type.getName().toLowerCase() + "s.elementAt(i).get" + 
            		CodeGeneratorUtils.getUpperCaseLeading(a.getName()) + "()));");
            writer.write(NEWLINE);
          }
          writer.write(NEWLINE);
          writer.write(CLOSED_BRACK);
          writer.write(NEWLINE);
          writer.write("if(data.size() < " + (index + 1) + ")");
          writer.write(NEWLINE);
          writer.write(OPEN_BRACK);
          writer.write(NEWLINE);
          writer.write("data.add(temp);");
          writer.write(NEWLINE);
          writer.write(CLOSED_BRACK);
          writer.write(NEWLINE);
          writer.write("else");
          writer.write(NEWLINE);
          writer.write(OPEN_BRACK);
          writer.write(NEWLINE);
          writer.write("data.setElementAt(temp, " + index + ");");
          writer.write(NEWLINE);
          writer.write(CLOSED_BRACK);
          writer.write(NEWLINE);
          writer.write(NEWLINE);
          index++;
        }
      }
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);

      // generate code for all visible-at-end attributes:
      writer.write("else // game over");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("data.clear();");
      writer.write(NEWLINE);
      writer.write("columnNames.clear();");
      writer.write(NEWLINE);

      writer.write("Vector<" + 
      		CodeGeneratorUtils.getUpperCaseLeading(type.getName()) + "> " + 
      				type.getName().toLowerCase() + "s = state.get" + 
      		SimSEObjectTypeTypes.getText(type.getType()) + 
      		"StateRepository().get" + 
      		CodeGeneratorUtils.getUpperCaseLeading(type.getName()) + 
      		"StateRepository().getAll();");
      writer.write(NEWLINE);
      writer.write("Vector<Object> ");
      writer.write("temp = new Vector<Object>();");
      writer.write(NEWLINE);
      index = 0;
	    for (int i = 0; i < atts.size(); i++) {
	      Attribute a = atts.elementAt(i);
	      if (a.isVisibleOnCompletion()) { // visible at end of game
	        writer.write("// Initialize " + a.getName() + ":");
	        writer.write(NEWLINE);
	        writer.write("if(columnNames.contains(\"" + a.getName()
	            + "\") == false)");
	        writer.write(NEWLINE);
	        writer.write(OPEN_BRACK);
	        writer.write(NEWLINE);
	        writer.write("columnNames.add(\"" + a.getName() + "\");");
	        writer.write(NEWLINE);
	        writer.write(CLOSED_BRACK);
	        writer.write("temp = new Vector<Object>();");
	        writer.write(NEWLINE);
	        writer.write("for(int i=0; i<" + type.getName().toLowerCase()
	            + "s.size(); i++)");
	        writer.write(NEWLINE);
	        writer.write(OPEN_BRACK);
	        writer.write(NEWLINE);
	        if (a.getType() == AttributeTypes.STRING) {
	          writer.write("temp.add(" + 
	          		type.getName().toLowerCase() + "s.elementAt(i).get" + 
	          		CodeGeneratorUtils.getUpperCaseLeading(a.getName()) + "());");
	        } else if (a.getType() == AttributeTypes.BOOLEAN) {
	          writer.write("temp.add(new Boolean(" + 
	          		type.getName().toLowerCase() + "s.elementAt(i).get" + 
	          		a.getName() + "()));");
	        } else if (a.getType() == AttributeTypes.INTEGER) {
	          writer.write("numFormat.setMinimumFractionDigits(0);");
	          writer.write(NEWLINE);
	          writer.write("numFormat.setMaximumFractionDigits(0);");
	          writer.write(NEWLINE);
	          writer.write("temp.add(numFormat.format(" + 
	          		type.getName().toLowerCase() + "s.elementAt(i).get" + 
	          		a.getName() + "()));");
	        } else if (a.getType() == AttributeTypes.DOUBLE) {
	          NumericalAttribute numAtt = (NumericalAttribute) a;
	          writer.write("numFormat.setMinimumFractionDigits(");
	          if (numAtt.getMinNumFractionDigits() != null) { // has min num
	                                                        	// fraction digits
	            writer.write(numAtt.getMinNumFractionDigits().toString());
	          } else {
	            writer.write("0");
	          }
	          writer.write(");");
	          writer.write(NEWLINE);
	          writer.write("numFormat.setMaximumFractionDigits(");
	          if (numAtt.getMaxNumFractionDigits() != null) { // has max num
	                                                          // fraction digits
	            writer.write(numAtt.getMaxNumFractionDigits().toString());
	          } else {
	            writer.write("16");
	          }
	          writer.write(");");
	          writer.write(NEWLINE);
	          writer.write("temp.add(numFormat.format("
	              + type.getName().toLowerCase() + "s.elementAt(i).get"
	              + a.getName() + "()));");
	          writer.write(NEWLINE);
	        }
	        writer.write(CLOSED_BRACK);
	        writer.write(NEWLINE);
	        writer.write("if(data.size() < " + (index + 1) + ")");
	        writer.write(NEWLINE);
	        writer.write(OPEN_BRACK);
	        writer.write(NEWLINE);
	        writer.write("data.add(temp);");
	        writer.write(NEWLINE);
	        writer.write(CLOSED_BRACK);
	        writer.write(NEWLINE);
	        writer.write("else");
	        writer.write(NEWLINE);
	        writer.write(OPEN_BRACK);
	        writer.write(NEWLINE);
	        writer.write("data.setElementAt(temp, " + index + ");");
	        writer.write(NEWLINE);
	        writer.write(CLOSED_BRACK);
	        writer.write(NEWLINE);
	        writer.write(NEWLINE);
	        index++;
	      }
	    }
      writer.write("fireTableStructureChanged();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer
          .write("fireTableDataChanged(); // notify listeners that table data has changed");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(NEWLINE);
      writer.write(NEWLINE);

      // getColumnClass method:
      writer.write("public Class getColumnClass(int c)");
      writer.write(NEWLINE);
      writer.write(OPEN_BRACK);
      writer.write(NEWLINE);
      writer.write("return getValueAt(0, c).getClass();");
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.write(NEWLINE);
      writer.write(CLOSED_BRACK);
      writer.close();
    } catch (IOException e) {
      JOptionPane.showMessageDialog(null, ("Error writing file "
          + tableModelFile.getPath() + ": " + e.toString()), "File IO Error",
          JOptionPane.WARNING_MESSAGE);
    }
  }
}