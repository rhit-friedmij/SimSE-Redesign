/*
 * This class is responsible for generating all of the code for the trigger
 * checker component in SimSE
 */

package simse.codegenerator.logicgenerator;

import simse.codegenerator.CodeGeneratorConstants;
import simse.codegenerator.CodeGeneratorUtils;

import simse.modelbuilder.actionbuilder.ActionType;
import simse.modelbuilder.actionbuilder.ActionTypeParticipant;
import simse.modelbuilder.actionbuilder.ActionTypeParticipantAttributeConstraint;
import simse.modelbuilder.actionbuilder.ActionTypeParticipantConstraint;
import simse.modelbuilder.actionbuilder.ActionTypeParticipantTrigger;
import simse.modelbuilder.actionbuilder.ActionTypeTrigger;
import simse.modelbuilder.actionbuilder.AttributeGuard;
import simse.modelbuilder.actionbuilder.AutonomousActionTypeTrigger;
import simse.modelbuilder.actionbuilder.DefinedActionTypes;
import simse.modelbuilder.actionbuilder.RandomActionTypeTrigger;
import simse.modelbuilder.actionbuilder.UserActionTypeTrigger;
import simse.modelbuilder.objectbuilder.AttributeTypes;
import simse.modelbuilder.objectbuilder.SimSEObjectType;
import simse.modelbuilder.objectbuilder.SimSEObjectTypeTypes;
import simse.modelbuilder.rulebuilder.Rule;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import java.util.Vector;

import javax.lang.model.element.Modifier;
import javax.swing.JOptionPane;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

public class TriggerCheckerGenerator implements CodeGeneratorConstants {
	private File directory; // directory to save generated code into
	private DefinedActionTypes actTypes; // holds all of the defined action types
	private File trigFile;
	
	// for keeping track of which vectors are being used in generated code so that
	// you don't generate the same ones more
	// than once -- e.g., Vector programmers state.getEmployeeStateRepository().
	// getProgrammerStateRepository().getAll()
	// will be generated more than once if you don't keep track of this.
	private Vector<String> vectors;
	private Vector<ActionTypeTrigger> nonPrioritizedTriggers;
	private Vector<ActionTypeTrigger> prioritizedTriggers;

	private ClassName vector = ClassName.get("java.util", "Vector");
	private ClassName ruleExecutor = ClassName.get("simse.logic", "RuleExecutor");

	public TriggerCheckerGenerator(DefinedActionTypes actTypes, File directory) {
		this.actTypes = actTypes;
		this.directory = directory;
		vectors = new Vector<String>();
		initializeTriggerLists();
	}

	public void generate() {
		ClassName random = ClassName.get("java.util", "Random");
		ClassName stage = ClassName.get("javafx.stage", "Stage");
		ClassName state = ClassName.get("simse.state", "State");

		MethodSpec triggerConstructor = MethodSpec.constructorBuilder()
				.addModifiers(Modifier.PUBLIC)
				.addParameter(state, "s")
				.addParameter(ruleExecutor, "r")
				.addStatement("state = s")
				.addStatement("ruleExec = r")
				.addStatement("ranNumGen = new $T()", random)
				.build();

		MethodSpec update = MethodSpec.methodBuilder("update")
				.addModifiers(Modifier.PUBLIC)
				.returns(void.class)
				.addParameter(boolean.class, "updateUserTrigsOnly")
				.addParameter(stage, "gui")
				.addCode(getTriggerConditions().build())
				.build();

		TypeSpec trigger = TypeSpec.classBuilder("TriggerChecker")
				.addModifiers(Modifier.PUBLIC)
				.addField(state, "state", Modifier.PRIVATE)
				.addField(ruleExecutor, "ruleExec", Modifier.PRIVATE)
				.addField(random, "ranNumGen", Modifier.PRIVATE)
				.addMethod(triggerConstructor)
				.addMethod(update)
				.build();

		JavaFile javaFile = JavaFile.builder("simse.logic", trigger)
				.addFileComment("File generated by: simse.codegenerator.logicgenerator.TriggerCheckerGenerator")
				.build();

		try {
			trigFile = new File(directory, ("simse\\logic\\TriggerChecker.java"));
			if (trigFile.exists()) {
				trigFile.delete(); // delete old version of file
			}
			FileWriter writer = new FileWriter(trigFile);
			javaFile.writeTo(writer);
			writer.close();
		} catch (IOException e) {
			JOptionPane.showMessageDialog(null, ("Error writing file " + trigFile.getPath() + ": " + e.toString()),
					"File IO Error", JOptionPane.WARNING_MESSAGE);
		}
	}

	private CodeBlock.Builder getTriggerConditions() {
		CodeBlock.Builder conditions = CodeBlock.builder();
		int counter = 0;
		// generate prioritized triggers:
		for (int i = 0; i < prioritizedTriggers.size(); i++) {
			conditions.add(generateTriggerChecker(prioritizedTriggers.elementAt(i), counter).build());
			counter++;
		}
		// generate non-prioritized triggers:
		for (int i = 0; i < nonPrioritizedTriggers.size(); i++) {
			conditions.add(generateTriggerChecker(nonPrioritizedTriggers.elementAt(i), counter).build());
			counter++;
		}
		return conditions;
	}

	private CodeBlock.Builder generateTriggerChecker(ActionTypeTrigger outerTrig, int counter) {
		ClassName alert = ClassName.get("javafx.scene.control", "Alert");
		ClassName alertType = ClassName.get("javafx.scene.control.Alert", "AlertType");
		ClassName customer = ClassName.get("simse.adts.objects", "Customer");
		ClassName employee = ClassName.get("simse.adts.objects", "Employee");
		ClassName simseGui = ClassName.get("simse.gui", "SimSEGUI");
		ClassName ssObject = ClassName.get("simse.adts.objects", "SSObject");
		TypeName vectorOfObjects = ParameterizedTypeName.get(vector, ssObject);
		
		CodeBlock.Builder checker = CodeBlock.builder();
		ActionType action = outerTrig.getActionType();
		String actType = CodeGeneratorUtils.getUpperCaseLeading(action.getName());
		String actTypeName = actType + "Action";
    	ClassName actName = ClassName.get("simse.adts.actions", actTypeName);
    	TypeName vectorOfActTypes = ParameterizedTypeName.get(vector, actName);
		
		if (!(outerTrig instanceof UserActionTypeTrigger)) { 
			// not a user trigger
			checker.beginControlFlow("if(!updateUserTrigsOnly)");
		}
		Vector<ActionTypeParticipantTrigger> triggers = outerTrig.getAllParticipantTriggers();
		for (int j = 0; j < triggers.size(); j++) {
			ActionTypeParticipantTrigger trig = triggers.elementAt(j);
			int partMetaType = trig.getParticipant().getSimSEObjectTypeType();
			String metaTypeName = CodeGeneratorUtils.getUpperCaseLeading(SimSEObjectTypeTypes.getText(partMetaType));
			String partName = trig.getParticipant().getName();
			String partTypeVarName = partName.toLowerCase() + "s" + counter;
			
			ClassName partType = ClassName.get("simse.adts.objects", metaTypeName);
			TypeName vectorOfPartType = ParameterizedTypeName.get(vector, partType);
			
			checker.addStatement("$T " + partTypeVarName + " = new $T()", vectorOfPartType, vectorOfPartType);
			
			Vector<ActionTypeParticipantConstraint> constraints = trig.getAllConstraints();
			for (int k = 0; k < constraints.size(); k++) {
				ActionTypeParticipantConstraint constraint = constraints.elementAt(k);
				String objTypeName = constraint.getSimSEObjectType().getName();
				String objTypeVarName = objTypeName.toLowerCase() + "s";
				String uCaseObjTypeName = CodeGeneratorUtils.getUpperCaseLeading(objTypeName);
				ClassName objType = ClassName.get("simse.adts.objects", uCaseObjTypeName);
				TypeName vectorOfObjTypes = ParameterizedTypeName.get(vector, objType);
				String constraintMetaTypeName = CodeGeneratorUtils.getUpperCaseLeading(
						SimSEObjectTypeTypes.getText(constraint.getSimSEObjectType().getType()));
				
				if (vectorContainsString(vectors, objTypeVarName) == false) {
					// this vector has not been generated already
					checker.addStatement("$T " + objTypeVarName + " = state.get" + constraintMetaTypeName 
							+ "StateRepository().get" + uCaseObjTypeName + "StateRepository().getAll()", vectorOfObjTypes);
					// generate it
					if (outerTrig instanceof UserActionTypeTrigger) { 
						// user trigger -- can be used by others
						// add it to the list:
						vectors.add(objTypeVarName);
					}
				}
				checker.beginControlFlow("for(int i = 0; i < " + objTypeVarName + ".size(); i++)");
				checker.addStatement("$T a = " + objTypeVarName + ".elementAt(i)", objType);
				checker.addStatement("$T allActions = state.getActionStateRepository().get"
						+ actTypeName + "StateRepository().getAllActions(a)", vectorOfActTypes);
				checker.addStatement("boolean alreadyInAction = false");

				if (partMetaType == SimSEObjectTypeTypes.EMPLOYEE || partMetaType == SimSEObjectTypeTypes.ARTIFACT) { 
					// employees and artifacts can only be in one of these actions in this role at a time
					checker.beginControlFlow("for (int j = 0; j < allActions.size(); j++) ");
					checker.addStatement("$T b = allActions.elementAt(j)", actName);
					checker.beginControlFlow("if (b.getAll" + partName + "s().contains(a)) ");
					checker.addStatement("alreadyInAction = true");
					checker.addStatement("break");
					checker.endControlFlow();
					checker.endControlFlow();
				}

				String ifCondition = "if((alreadyInAction == false) ";

				ActionTypeParticipantAttributeConstraint[] attConstraints = constraint.getAllAttributeConstraints();
				for (int m = 0; m < attConstraints.length; m++) {
					ActionTypeParticipantAttributeConstraint attConst = attConstraints[m];
					if (attConst.isConstrained()) {
						ifCondition += " && (a.get"
								+ CodeGeneratorUtils.getUpperCaseLeading(attConst.getAttribute().getName())
								+ "() ";
						if (attConst.getAttribute().getType() == AttributeTypes.STRING) {
							ifCondition += ".equals(" + "\"" + attConst.getValue().toString() + "\")";
						} else {
							if (attConst.getGuard().equals(AttributeGuard.EQUALS)) {
								ifCondition += "== ";
							} else {
								ifCondition += attConst.getGuard() + " ";
							}
							ifCondition += attConst.getValue().toString();
						}
						ifCondition += ")";
					}
				}
				ifCondition += ")";
				checker.beginControlFlow(ifCondition);
				checker.addStatement(partTypeVarName + ".add(a)");
				checker.endControlFlow();
				checker.endControlFlow();
			}
		}
		
		String condition = "";
		if (outerTrig instanceof UserActionTypeTrigger) {
			condition += "if (" ;
		} else if (outerTrig instanceof AutonomousActionTypeTrigger || outerTrig instanceof RandomActionTypeTrigger) {
			condition += "while (";
		}
		Vector<ActionTypeParticipant> parts = action.getAllParticipants();
		for (int k = 0; k < parts.size(); k++) {
			ActionTypeParticipant part = parts.elementAt(k);
			if (k > 0) { 
				// not on first element
				condition += " && ";
			}
			String partVarName = part.getName().toLowerCase() + "s" + counter;
			condition += "(" + partVarName + ".size() ";
			if (part.getQuantity().isMinValBoundless()) {
				if (part.getSimSEObjectTypeType() == SimSEObjectTypeTypes.EMPLOYEE) {
					condition += "> 0)";
				} else { 
					// non-employee
					condition += ">= 0)";
				}
			} else { 
				// min val bounded
				condition += " >= " + part.getQuantity().getMinVal().intValue() + ")";
			}
		}
		condition += ")";
		if (parts.size() > 0) {
			checker.beginControlFlow(condition);
		}
		
		if (outerTrig instanceof UserActionTypeTrigger) {
			// go through each participant, and if it's an employee, add the text to their menu:
			for (int k = 0; k < parts.size(); k++) {
				ActionTypeParticipant part = parts.elementAt(k);
				String partVarName = part.getName().toLowerCase() + "s" + counter;
				if (part.getSimSEObjectTypeType() == SimSEObjectTypeTypes.EMPLOYEE) {
					checker.beginControlFlow("for(int j = 0; j < " + partVarName + ".size(); j++)");
					checker.addStatement("$T z = ($T)" + partVarName + ".elementAt(j)", employee, employee);
					checker.addStatement("z.addMenuItem(\"" + ((UserActionTypeTrigger) outerTrig).getMenuText() + "\")");
					checker.endControlFlow();
				}
			}
		} else if ((outerTrig instanceof AutonomousActionTypeTrigger) || (outerTrig instanceof RandomActionTypeTrigger)) {
			checker.addStatement("$T a = new $T()", actName, actName);
			for (int k = 0; k < parts.size(); k++) {
				ActionTypeParticipant part = parts.elementAt(k);
				String partVarName = part.getName().toLowerCase() + "s" + counter;
				int partObjType = part.getSimSEObjectTypeType();
				String partMetaTypeName = CodeGeneratorUtils.getUpperCaseLeading(SimSEObjectTypeTypes.getText(partObjType));
				ClassName partMetaTypeClass = ClassName.get("simse.adts.objects", partMetaTypeName);
				
				String boundCondition = "";
				if (part.getQuantity().isMaxValBoundless()) {
					boundCondition = "while (true)";
				} else { // max bounded
					boundCondition = "for (int i = 0; i < " + part.getQuantity().getMaxVal().intValue() + "; i++)";
				}
				checker.beginControlFlow(boundCondition);
				checker.beginControlFlow("if(" + partVarName + ".size() > 0)");
				
				String objManipulation = "";
				if (partObjType == SimSEObjectTypeTypes.ARTIFACT || partObjType == SimSEObjectTypeTypes.EMPLOYEE) { 
					// can't be in more than one action of the same type at a time
					objManipulation = ".remove(0)";
				} else {
					objManipulation = ".elementAt(0)";
				}
				checker.addStatement("$T a" + k + " = " + partVarName + objManipulation, partMetaTypeClass);
				checker.addStatement("a.add" + part.getName() + "(a" + k + ")");
				checker.nextControlFlow("else");
				checker.addStatement("break");
				checker.endControlFlow();
				checker.endControlFlow();
			}

			// RANDOM TRIGGER:
			if (outerTrig instanceof RandomActionTypeTrigger && ((RandomActionTypeTrigger) outerTrig).getFrequency() < 100.0) {
				// have to put the < 100 here because otherwise it might not always be
				// triggered (if ran num is 100 and frequency is 100)
				checker.beginControlFlow("if((ranNumGen.nextDouble() * 100.0) < "
						+ (((RandomActionTypeTrigger) outerTrig).getFrequency()) + ")");
			}
			checker.add("// set all overhead texts:\n");
			checker.addStatement("$T allPart = a.getAllParticipants()", vectorOfObjects);
			checker.beginControlFlow("for (int i = 0; i < allPart.size(); i++)");
			checker.addStatement("$T tempObj = allPart.elementAt(i)", ssObject);
			checker.beginControlFlow("if (tempObj instanceof $T)", employee);
			
			if ((outerTrig.getTriggerText() != null) && (outerTrig.getTriggerText().length() > 0)) { 
				// has trigger text
				checker.addStatement("(($T) tempObj).setOverheadText(\"" + outerTrig.getTriggerText() + "\")", employee);
			}
			checker.nextControlFlow("else if (tempObj instanceof $T)", customer);
			checker.addStatement("(($T) tempObj).setOverheadText(\"" + outerTrig.getTriggerText() + "\")", customer);
			checker.endControlFlow();
			checker.endControlFlow();
			checker.addStatement("state.getActionStateRepository().get" + actTypeName + "StateRepository().add(a)");
			// execute all trigger rules:
			Vector<Rule> trigRules = action.getAllTriggerRules();
			for (int i = 0; i < trigRules.size(); i++) {
				Rule tRule = trigRules.elementAt(i);
				checker.addStatement("ruleExec.update(gui, $T.UPDATE_ONE, \"" + tRule.getName() + "\", a)", ruleExecutor);
			}

			// game-ending:
			if (outerTrig.isGameEndingTrigger()) {
				checker.add("// stop game and give score:\n");
				checker.addStatement("$T t111 = ($T)a", actName, actName);
				
				// find the scoring attribute:
				ActionTypeParticipantTrigger scoringPartTrig = null;
				ActionTypeParticipantConstraint scoringPartConst = null;
				ActionTypeParticipantAttributeConstraint scoringAttConst = null;
				Vector<ActionTypeParticipantTrigger> partTrigs = outerTrig.getAllParticipantTriggers();
				for (int k = 0; k < partTrigs.size(); k++) {
					ActionTypeParticipantTrigger partTrig = partTrigs.elementAt(k);
					Vector<ActionTypeParticipantConstraint> partConsts = partTrig.getAllConstraints();
					for (int m = 0; m < partConsts.size(); m++) {
						ActionTypeParticipantConstraint partConst = partConsts.elementAt(m);
						ActionTypeParticipantAttributeConstraint[] attConsts = partConst
								.getAllAttributeConstraints();
						for (int n = 0; n < attConsts.length; n++) {
							if (attConsts[n].isScoringAttribute()) {
								scoringAttConst = attConsts[n];
								scoringPartConst = partConst;
								scoringPartTrig = partTrig;
								break;
							}
						}
					}
				}
				String scoringPartVarName = scoringPartTrig.getParticipant().getName() + "s";
				String scoringPartConstObj = CodeGeneratorUtils
						.getUpperCaseLeading(scoringPartConst.getSimSEObjectType().getName());
				ClassName scoringPartConstObjName = ClassName.get("simse.adts.objects", scoringPartConstObj);
				if ((scoringAttConst != null) && (scoringPartConst != null) && (scoringPartTrig != null)) {
					checker.beginControlFlow("if (t111.getAll" + scoringPartVarName + "().size() > 0)");
					checker.addStatement("$T t = ($T)(t111.getAll" + scoringPartVarName + "().elementAt(0))"
							, scoringPartConstObjName, scoringPartConstObjName);
					checker.beginControlFlow("if (t != null)");
					Class scoreType = null;
					if (scoringAttConst.getAttribute().getType() == AttributeTypes.INTEGER) {
						scoreType = int.class;
					} else if (scoringAttConst.getAttribute().getType() == AttributeTypes.DOUBLE) {
						scoreType = double.class;
					} else if (scoringAttConst.getAttribute().getType() == AttributeTypes.STRING) {
						scoreType = String.class;
					} else if (scoringAttConst.getAttribute().getType() == AttributeTypes.BOOLEAN) {
						scoreType = boolean.class;
					}
					checker.addStatement("$T v = t.get" + scoringAttConst.getAttribute().getName() + "()", scoreType);
					checker.addStatement("state.getClock().stop()");
					checker.addStatement("state.setScore(v)");
					checker.addStatement("(($T)gui).update()", simseGui);
					checker.addStatement("$T d = new $T($T.INFORMATION)", alert, alert, alertType);
					checker.addStatement("d.setContentText(($S + v))", "Your score is ");
					checker.addStatement("d.setTitle($S)", "Game over!");
					checker.addStatement("d.setHeaderText(null)");
					checker.addStatement("d.showAndWait()");
					checker.endControlFlow();
					checker.endControlFlow(); // game ending if condition
				}
			}

			// RANDOM TRIGGER:
			if (outerTrig instanceof RandomActionTypeTrigger && ((RandomActionTypeTrigger) outerTrig).getFrequency() < 100.0) {
				// have to put the < 100 here because otherwise it might not always be
				// triggered (if ran num is 100 and frequency is 100)
				checker.endControlFlow();
			}
		}
		if (parts.size() > 0) {
			checker.endControlFlow();
		}
		if (!(outerTrig instanceof UserActionTypeTrigger)) { 
			// not a user trigger
			checker.endControlFlow();
		}

		// JOINING existing actions:
		if ((outerTrig instanceof UserActionTypeTrigger) && (action.isJoiningAllowed())) {
			int cnt = counter + 2;
			String oneActCnt = "a" + cnt;
			String actCntVar = oneActCnt + "s";
			String empCntVar = "f" + cnt;
			
			checker.addStatement("$T $L = state.getActionStateRepository().get"
					+ actTypeName + "StateRepository().getAllActions()", vector, actCntVar);
			checker.beginControlFlow("if ($L.size() == 0)", actCntVar);
			checker.addStatement("$T $L = state.getEmployeeStateRepository().getAll()", vector, empCntVar);
			checker.beginControlFlow("for (int i = 0; i < $L.size(); i++)", empCntVar);
			checker.addStatement("(($T) $L.elementAt(i)).removeMenuItem($S)", employee, empCntVar,
					((UserActionTypeTrigger) outerTrig).getMenuText());
			checker.endControlFlow();
			checker.endControlFlow();
			checker.beginControlFlow("for (int i = 0; i < $L.size(); i++)", actCntVar);
			checker.addStatement("$T $L = ($T) $L.elementAt(i)", actName, oneActCnt, actName, actCntVar);
			
			// go through all participants:
			for (int j = 0; j < parts.size(); j++) {
				ActionTypeParticipant part = parts.elementAt(j);
				int partObjType = part.getSimSEObjectTypeType();
				String partName = part.getName();
				
				if (partObjType == SimSEObjectTypeTypes.EMPLOYEE) {
					// employee participant, hence, a role this employee could play
					String bound = "";
					if (part.getQuantity().isMaxValBoundless()) {
						bound = "999999";
					} else { // max val has a value
						bound = part.getQuantity().getMaxVal().toString();
					}
					checker.beginControlFlow("if ($L.getAll$Ls().size() < $L)", oneActCnt, partName, bound);
					
					String oneObjCnt = "b" + cnt;
					String objCntVar = oneObjCnt + "s";
					String empBool = "z" + cnt;
					
					checker.addStatement("$T $L = state.getEmployeeStateRepository().getAll()", vector, objCntVar);
					checker.beginControlFlow("for (int j = 0; j < $L.size(); j++)", objCntVar);
					checker.addStatement("$T $L = ($T) $L.elementAt(j)", employee, oneObjCnt, employee, objCntVar);
					
					String objCondition = "if ((";
					// go through each SimSEObjectType:
					Vector<SimSEObjectType> types = part.getAllSimSEObjectTypes();
					for (int k = 0; k < types.size(); k++) {
						SimSEObjectType tempType = types.elementAt(k);
						String tempName = CodeGeneratorUtils.getUpperCaseLeading(tempType.getName());
						if (k > 0) { 
							// not on first element
							objCondition += " || ";
						}
						objCondition += "(" + oneObjCnt + " instanceof " + tempName + ")";
					}
					objCondition += ") && (" + oneActCnt + ".getAll" + partName + "s().contains(" + oneObjCnt + ") == false))";
					checker.beginControlFlow(objCondition);
					checker.addStatement("$T $L = true", boolean.class, empBool);
					checker.beginControlFlow("for (int k = 0; k < $L.size(); k++)", actCntVar);
					checker.addStatement("$T a" + cnt + "b = ($T) $L.elementAt(k)", actName, actName, actCntVar);
					checker.beginControlFlow("if(a" + cnt + "b.getAll" + partName + "s().contains($L))", oneObjCnt);
					checker.addStatement("$L = false", empBool);
					checker.addStatement("break");
					checker.endControlFlow();
					checker.endControlFlow();
					checker.beginControlFlow("if($L && ($L.getMenu().contains($S) == false))", empBool, oneObjCnt, 
							"JOIN " + ((UserActionTypeTrigger) outerTrig).getMenuText());
					
					// go through all participant constraints:
					for (int k = 0; k < types.size(); k++) {
						SimSEObjectType tempType = types.elementAt(k);
						String objTypeName = tempType.getName();
						String objTypeClassName = CodeGeneratorUtils.getUpperCaseLeading(objTypeName);
						ClassName objTypeClass = ClassName.get("simse.adts.objects", objTypeClassName);
						
						String instanceCond = "if ((" + oneObjCnt + " instanceof " + objTypeClassName + ")";			
						
						// go through all attribute constraints:
						ActionTypeParticipantAttributeConstraint[] attConstraints = outerTrig
								.getParticipantTrigger(part.getName()).getConstraint(tempType.getName())
								.getAllAttributeConstraints();
						for (int m = 0; m < attConstraints.length; m++) {
							ActionTypeParticipantAttributeConstraint attConst = attConstraints[m];
							if (attConst.isConstrained()) {
								instanceCond += " && ((("+ objTypeClassName + ") " + oneObjCnt + ").get" + CodeGeneratorUtils
										.getUpperCaseLeading(attConst.getAttribute().getName())	+ "() ";
								
								if (attConst.getAttribute().getType() == AttributeTypes.STRING) {
									instanceCond += ".equals(\"" + attConst.getValue().toString() + "\")";
								} else {
									if (attConst.getGuard().equals(AttributeGuard.EQUALS)) {
										instanceCond += "== ";
									} else {
										instanceCond += attConst.getGuard() + " ";
									}
									instanceCond += attConst.getValue().toString();
								}
								instanceCond += ")";
							}
						}
						instanceCond += ")";
						if (k == 0) { 
							// on first element
							checker.beginControlFlow(instanceCond);
						} else {
							checker.nextControlFlow("else " + instanceCond);
						}
						checker.addStatement("$L.addMenuItem($S)", oneObjCnt, "JOIN " + ((UserActionTypeTrigger) outerTrig).getMenuText());
						if (k == types.size() - 1) {
							checker.endControlFlow();
						}
					}
					checker.endControlFlow();
					checker.endControlFlow();
					checker.endControlFlow();
				}
			}
			checker.endControlFlow();
			checker.endControlFlow();
		}
		return checker;
	}

	private boolean vectorContainsString(Vector<String> v, String s) {
		for (int i = 0; i < v.size(); i++) {
			String temp = v.elementAt(i);
			if (temp.equals(s)) {
				return true;
			}
		}
		return false;
	}

	/*
	 * gets the triggers in prioritized order according to their priority
	 */
	private void initializeTriggerLists() {
		// initialize lists:
		nonPrioritizedTriggers = new Vector<ActionTypeTrigger>();
		prioritizedTriggers = new Vector<ActionTypeTrigger>();
		Vector<ActionType> allActions = actTypes.getAllActionTypes();
		// go through all action types and get their triggers:
		for (int i = 0; i < allActions.size(); i++) {
			ActionType tempAct = allActions.elementAt(i);
			Vector<ActionTypeTrigger> trigs = tempAct.getAllTriggers();
			for (int j = 0; j < trigs.size(); j++) {
				ActionTypeTrigger tempTrig = trigs.elementAt(j);
				int priority = tempTrig.getPriority();
				if (priority == -1) { // trigger is not prioritized
					nonPrioritizedTriggers.addElement(tempTrig);
				} else { 
					// priority >= 0
					if (prioritizedTriggers.size() == 0) { 
						// no elements have been added yet to the prioritized trigger list
						prioritizedTriggers.add(tempTrig);
					} else {
						// find the correct position to insert the trigger at:
						for (int k = 0; k < prioritizedTriggers.size(); k++) {
							ActionTypeTrigger tempA = prioritizedTriggers.elementAt(k);
							if (priority <= tempA.getPriority()) {
								// insert the trigger
								prioritizedTriggers.insertElementAt(tempTrig, k); 
								break;
							} else if (k == (prioritizedTriggers.size() - 1)) { 
								// on the last element
								// add the trigger to the end of the list
								prioritizedTriggers.add(tempTrig); 
								break;
							}
						}
					}
				}
			}
		}
	}
}